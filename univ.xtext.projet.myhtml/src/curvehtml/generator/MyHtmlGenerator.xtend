/*
* generated by Xtext 2.25.0
 */
package curvehtml.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import curveHTLM.html_generator_program
import curveHTLM.statement
import curveHTLM.graph
import curveHTLM.csv_loader
import curveHTLM.curve
import java.util.ArrayList
import java.util.List
import java.io.BufferedReader
import java.io.FileReader
import java.io.IOException

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyHtmlGenerator extends AbstractGenerator {

	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var html_generator_program prog = resource.allContents.head as html_generator_program;
		
		var String style = "";
		var csv_name = "";
		var x_axis = "";
		var courbe = "";
		var separator = "";
		//var List<String> arguments = new ArrayList<String>(Arrays.asList("Car", "Horsepower", "MPG"));
		var List<String> arguments = new ArrayList<String>;
		
		for (s : prog.statement){
			if (s instanceof graph){
				style = s.style.toString 
				x_axis = s.x_axis.toString 
				arguments.add(s.x_axis.toString)
				for (curve:s.curve) {
					courbe += getcourbe(curve)
					arguments.add(curve.label_name.toString)
				}
			}
			if (s instanceof csv_loader){
				csv_name += s.file_name
				separator += s.separator
			}
		}
		
		var data = getdata(csv_name,separator, arguments);
		

		
		var String html = '''
<!DOCTYPE html>
<head>
</head>
<body>
  <div>
    <canvas id="myChart"></canvas>
  </div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- <script src="https://raw.githubusercontent.com/chartjs/Chart.js/master/docs/scripts/utils.js"></script> -->
<script>
  
const data = [
«data»
];
new Chart(
    document.getElementById('myChart'),
    {
      type: '«style»',
      data: {
              labels: data.map(row => row.«x_axis»),
              datasets: [
              «courbe»]
            }
     }
);
</script>
</body>
</html>
'''


		var inputFile = resource.URI.trimFragment().lastSegment().toString()
		var outputFile = inputFile.substring(0, inputFile.lastIndexOf('.')) + ".html"
		fsa.generateFile(outputFile, html)
	
	}
	
	def getcourbe(curve c){
		var res='''
          {
            label: '«c.legend.toString»',
            data: data.map(row => row.«syntax(c.label_name.toString)»),
'''		
		if (c.color != null){
			res+="	backgroundColor :'" + c.color +"',\n"
			res+="	borderColor :'" + c.color +"',\n"
		}
		res+="},\n"
		return res
	}
	
	def syntax(String s){
		var res = ""
		res=s.replace("(", "_").replace(")", "_").replace(" ", "_").replace("-","_")
		
		return res.toString()
	}
	
	def getdata(String csvFile, String cvsSplitBy,  List<String> arguments){
		var List<Integer> order = new ArrayList<Integer>()

		var res = new StringBuilder();
		var line = "";
		
		for (var a =0; a < arguments.size(); a++) {
			order.add(a);
		}

		try(var br = new BufferedReader(new FileReader(csvFile))){
			line = br.readLine();
			var entry = line.split(cvsSplitBy);
			
			
			for (var i =0; i < arguments.size(); i++){
				if (!entry.contains(arguments.get(i))){
					throw new IOException("Error in label name \""+ arguments.get(i) + "\", please check")
				}
			}
			
			
			for (var j = 0; j < arguments.size(); j++) {
				var arg = arguments.get(j);
				for (var i = 0; i < entry.length; i++) {
					 if ((entry.get(i)).equals(arg)) {
					    order.set(j, i);
					    
					 }
				}
			}
			

		    while ((line = br.readLine()) != null) {
		        var data = line.split(cvsSplitBy);
		        
		        if (data.length > 1 && !(data.get(0)).matches("(?i)STRING|DOUBLE|INT|CAT")) {
		            res.append("{");
		            for (var i = 0; i < arguments.size(); i++) {
		            	if (data.length > order.get(i)){
		                	res.append(syntax(arguments.get(i)) +  ":\"" + data.get(order.get(i))+ "\", ");
		                }
		                else{
		                	res.append(syntax(arguments.get(i)) + ":\"" + "\", " )
		                }
		            }
		            res.append("},\n");
		        }
		    }
		} 
		catch (IOException e) {
		    e.printStackTrace();
		}
		return res.toString()
	}
}



